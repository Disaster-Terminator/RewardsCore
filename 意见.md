é’ˆå¯¹ä½ æå‡ºçš„ 5 ä¸ªå…³é”®ä¸æ˜ç¡®ç‚¹ï¼Œé€šè¿‡æ·±åº¦æŠ€æœ¯åˆ†æï¼Œæˆ‘åˆ¶å®šäº†ä»¥ä¸‹**ç¡®å®šçš„å®æ–½ç­–ç•¥**ã€‚è¿™äº›ç­–ç•¥å°†ç›´æ¥ä½“ç°åœ¨å³å°†ç”Ÿæˆçš„ä»£ç ä¸­ã€‚

### ğŸ›¡ï¸ ä¸æ˜ç¡®ç‚¹å†³æ–­ä¸ä¿®æ­£

1. **å…³äº GraphQL Node ID (å…³é”®ä¿®æ­£)**
    * **å†³æ–­**ï¼šæ˜¯çš„ï¼Œå¿…é¡»å­˜å‚¨ GraphQL Node IDã€‚
    * **ä¿®æ­£**ï¼šGitHub çš„ `resolveReviewThread` mutation éœ€è¦çš„æ˜¯ **Thread ID** (ä¾‹å¦‚ `MDI0OlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMTIzNDU2`), è€Œä¸æ˜¯å•æ¡è¯„è®ºçš„ IDã€‚
    * **å®ç°**ï¼š`fetch-reviews` å°†ä¸å†æ‹‰å–æ‰å¹³çš„ commentsï¼Œæ”¹ä¸ºæ‹‰å– `reviewThreads`ã€‚æ•°æ®æ¨¡å‹ä¸­å°†å¢åŠ  `thread_id` å­—æ®µä½œä¸ºè§£å†³æ“ä½œçš„ä¸»é”®ã€‚

2. **å…³äºçŠ¶æ€åŒæ­¥**
    * **å†³æ–­**ï¼šé‡‡ç”¨ **"API First, DB Second"** (æ‚²è§‚é”) ç­–ç•¥ã€‚
    * **å®ç°**ï¼šå…ˆè°ƒç”¨ GitHub Mutationã€‚åªæœ‰ API è¿”å› `isResolved: true` åï¼Œæ‰æ›´æ–° TinyDBã€‚å¦‚æœ API å¤±è´¥ï¼ŒæŠ›å‡ºå¼‚å¸¸ï¼ŒTinyDB ä¿æŒ `pending`ï¼Œç¡®ä¿æ•°æ®æœ€ç»ˆä¸€è‡´æ€§ã€‚

3. **å…³äº Qodo è§£æè§„åˆ™**
    * **å†³æ–­**ï¼šæ”¾å¼ƒè„†å¼±çš„å­—ç¬¦ä¸²åˆ†å‰²ï¼Œå¼•å…¥ **Regex (æ­£åˆ™è¡¨è¾¾å¼)**ã€‚
    * **å®ç°**ï¼š
        * **å·²è§£å†³**ï¼š`^\s*[â˜‘âœ…]` (åŒ¹é…è¡Œé¦–çš„ â˜‘ æˆ– âœ…)
        * **ç±»å‹å‰ç¼€**ï¼š`^\s*âœ“\s+\w+` (åŒ¹é… âœ“ åè·Ÿç©ºæ ¼å’Œæ–‡å­—ï¼Œå¦‚ `âœ“ Correctness`) -> **æ ‡è®°ä¸º Pending**ã€‚

4. **å…³äº ETag ä¸ GraphQL ä¸€è‡´æ€§**
    * **å†³æ–­**ï¼šæ¥å—å¾®å°çš„ Race Conditionã€‚
    * **åˆ†æ**ï¼šETag å˜åŒ–æ„å‘³ç€æœåŠ¡ç«¯æœ‰æ›´æ–°ã€‚å¦‚æœ GraphQL å°šæœªåŒæ­¥ï¼ˆæä½æ¦‚ç‡ï¼‰ï¼Œæˆ‘ä»¬åªæ˜¯å¤šè¯»äº†ä¸€æ¬¡æ—§æ•°æ®ï¼ˆå¹‚ç­‰æ“ä½œï¼‰ï¼Œä¸ä¼šé€ æˆç ´åã€‚ä¸‹ä¸€æ¬¡è½®è¯¢ä¼šè‡ªåŠ¨ä¿®æ­£ã€‚æ— éœ€å¤æ‚çš„é‡è¯•é”ã€‚

5. **å…³äº Spec åºŸå¼ƒ**
    * **å†³æ–­**ï¼š**å…¨é‡æ›¿æ¢**ã€‚
    * **å®ç°**ï¼šç°æœ‰ spec ä¸­çš„ Playwright é€»è¾‘å°†è¢«æ ‡è®°ä¸º `DEPRECATED`ã€‚v2 ä»£ç åº“å°†æˆä¸ºå”¯ä¸€çš„ Truth Sourceã€‚

---

### ğŸš€ ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€è®¾æ–½ä»£ç å®ç° (v2 Core)

æˆ‘å°†åˆ›å»ºæ ¸å¿ƒçš„ Python æ¨¡å—ã€‚è¯·åœ¨ä½ çš„é¡¹ç›®ä¸­æ‰§è¡Œä»¥ä¸‹æ–‡ä»¶åˆ›å»ºã€‚

#### 1. æ•°æ®æ¨¡å‹ (`src/review/models.py`)

è¿™é‡Œæ˜ç¡®äº† ID çš„ç±»å‹å’Œ Qodo çš„çŠ¶æ€å®šä¹‰ã€‚

```python
from pydantic import BaseModel, Field
from typing import Optional, List
from datetime import datetime

class ReviewThreadState(BaseModel):
    """
    å®¡æŸ¥çº¿ç¨‹æ¨¡å‹ (å¯¹åº” GitHub ReviewThread)
    æ³¨æ„ï¼šæˆ‘ä»¬è§£å†³çš„æ˜¯ Threadï¼Œè€Œä¸æ˜¯å•ä¸ª Comment
    """
    id: str = Field(..., description="GraphQL Node ID (Base64), ç”¨äº mutation")
    is_resolved: bool = Field(False, description="GitHub ä¸Šçš„è§£å†³çŠ¶æ€")
    
    # çº¿ç¨‹ä¸­çš„ç¬¬ä¸€æ¡è¯„è®ºé€šå¸¸åŒ…å« AI çš„ä¸»è¦å»ºè®®
    primary_comment_body: str = ""
    
    # æ¥æºåˆ†æ
    source: str = Field(..., description="Sourcery / Qodo / Copilot")
    file_path: str = ""
    line_number: int = 0
    
    # æœ¬åœ°å¤„ç†çŠ¶æ€
    local_resolution_status: str = Field("pending", description="pending / resolved / ignored")
    resolution_type: Optional[str] = None # code_fixed / dismissed / manual
    
    last_updated: str = Field(default_factory=lambda: datetime.utcnow().isoformat())

class ReviewMetadata(BaseModel):
    pr_number: int
    owner: str
    repo: str
    last_updated: str
    etag_comments: Optional[str] = None
    etag_reviews: Optional[str] = None

class ReviewDbSchema(BaseModel):
    metadata: ReviewMetadata
    threads: List[ReviewThreadState] = []
```

#### 2. è§£æå™¨ (`src/review/parsers.py`)

è§£å†³äº† Qodo å›¾æ ‡æ··æ·†çš„é—®é¢˜ï¼Œä½¿ç”¨ Regex å¢å¼ºå¥å£®æ€§ã€‚

```python
import re

class ReviewParser:
    # åŒ¹é… Qodo/Sourcery çš„å·²è§£å†³æ ‡å¿—
    # â˜‘ (U+2611), âœ… (U+2705)
    REGEX_RESOLVED = re.compile(r"^\s*[â˜‘âœ…]|âœ…\s*Addressed", re.MULTILINE)
    
    # åŒ¹é… Qodo çš„åˆ†ç±»å‰ç¼€ (éè§£å†³æ ‡å¿—)
    # âœ“ (U+2713) åè·Ÿç©ºæ ¼
    REGEX_CATEGORY = re.compile(r"^\s*âœ“\s+\w+", re.MULTILINE)

    @classmethod
    def parse_status(cls, body: str, is_resolved_on_github: bool) -> str:
        """
        è§£æè¯„è®ºçŠ¶æ€
        ä¼˜å…ˆçº§ï¼šGitHubåŸç”ŸçŠ¶æ€ > AIæ–‡æœ¬æ ‡è®° > é»˜è®¤
        """
        # 1. å¦‚æœ GitHub ä¸Šå·²ç»æ ‡è®°ä¸º Resolved (æŠ˜å )ï¼Œåˆ™ç»å¯¹æ˜¯ resolved
        if is_resolved_on_github:
            return "resolved"
            
        body = body.strip()
        
        # 2. æ£€æŸ¥æ–‡æœ¬ç‰¹å¾
        if cls.REGEX_RESOLVED.search(body):
            return "resolved"
            
        # 3. æ£€æŸ¥æ˜¯å¦ä»…ä»…æ˜¯åˆ†ç±»æ ‡ç­¾ (å¦‚ "âœ“ Correctness")
        # è¿™ä¸€æ­¥å…¶å®æ˜¯é˜²å¾¡æ€§çš„ï¼Œå› ä¸ºå¦‚æœä¸æ˜¯ Resolvedï¼Œé»˜è®¤å°±æ˜¯ Pending
        # ä½†æ˜ç¡®åˆ—å‡ºæœ‰åŠ©äºè°ƒè¯•
        if cls.REGEX_CATEGORY.match(body):
            return "pending"
            
        return "pending"

    @classmethod
    def detect_source(cls, author_login: str) -> str:
        login = author_login.lower()
        if "sourcery" in login:
            return "Sourcery"
        elif "qodo" in login or "codium" in login:
            return "Qodo"
        elif "copilot" in login:
            return "Copilot"
        return "Unknown"
```

#### 3. GraphQL å®¢æˆ·ç«¯ (`src/review/graphql_client.py`)

è§£å†³äº† Node ID è·å–å’Œ Mutation è°ƒç”¨ã€‚

```python
import httpx
import logging
from typing import Dict, Any, List

logger = logging.getLogger(__name__)

class GraphQLClient:
    def __init__(self, token: str):
        self.endpoint = "https://api.github.com/graphql"
        self.headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

    def _execute(self, query: str, variables: Dict[str, Any] = {}) -> Dict[str, Any]:
        response = httpx.post(
            self.endpoint,
            json={"query": query, "variables": variables},
            headers=self.headers,
            timeout=30.0
        )
        response.raise_for_status()
        data = response.json()
        if "errors" in data:
            raise Exception(f"GraphQL Error: {data['errors']}")
        return data["data"]

    def fetch_pr_threads(self, owner: str, repo: str, pr_number: int) -> List[Dict]:
        """
        è·å– PR çš„è¯„è®ºçº¿ç¨‹ (åŒ…å« Node ID)
        """
        query = """
        query($owner: String!, $repo: String!, $pr: Int!) {
          repository(owner: $owner, name: $repo) {
            pullRequest(number: $pr) {
              reviewThreads(last: 50) {
                nodes {
                  id
                  isResolved
                  path
                  line
                  comments(first: 1) {
                    nodes {
                      author { login }
                      body
                    }
                  }
                }
              }
            }
          }
        }
        """
        data = self._execute(query, {"owner": owner, "repo": repo, "pr": pr_number})
        return data["repository"]["pullRequest"]["reviewThreads"]["nodes"]

    def resolve_thread(self, thread_id: str) -> bool:
        """
        è§£å†³çº¿ç¨‹ (Mutation)
        """
        mutation = """
        mutation($threadId: ID!) {
          resolveReviewThread(input: {threadId: $threadId}) {
            thread {
              isResolved
            }
          }
        }
        """
        try:
            data = self._execute(mutation, {"threadId": thread_id})
            return data["resolveReviewThread"]["thread"]["isResolved"]
        except Exception as e:
            logger.error(f"Failed to resolve thread {thread_id}: {e}")
            raise
```

#### 4. çŠ¶æ€ç®¡ç†å™¨ (`src/review/comment_manager.py`)

å¼•å…¥ `filelock` è§£å†³å¹¶å‘é—®é¢˜ï¼Œä½¿ç”¨ TinyDB æŒä¹…åŒ–ã€‚

```python
from tinydb import TinyDB, Query
from pathlib import Path
from filelock import FileLock
from typing import List, Optional
from datetime import datetime
from .models import ReviewThreadState, ReviewMetadata, ReviewDbSchema

class ReviewManager:
    def __init__(self, db_path: str = ".trae/data/review_comments.json"):
        self.db_path = Path(db_path)
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        self.lock_path = self.db_path.with_suffix(".lock")
        
        self.db = TinyDB(self.db_path)
        self.Thread = Query()
        self.Metadata = Query()

    def save_threads(self, threads: List[ReviewThreadState], metadata: ReviewMetadata):
        """å…¨é‡ä¿å­˜/æ›´æ–°çº¿ç¨‹çŠ¶æ€"""
        with FileLock(self.lock_path):
            # æ›´æ–° Metadata
            meta_table = self.db.table("metadata")
            meta_table.truncate()
            meta_table.insert(metadata.model_dump())
            
            # æ›´æ–° Threads (ä½¿ç”¨ upsert é˜²æ­¢è¦†ç›–æ‰‹åŠ¨ä¿®æ”¹çš„çŠ¶æ€)
            thread_table = self.db.table("threads")
            for thread in threads:
                # ä»…å½“ ID ä¸å­˜åœ¨æ—¶æ’å…¥ï¼Œæˆ–è€…æ›´æ–°æ¥è‡ª GitHub çš„å¼ºåˆ¶çŠ¶æ€
                # æ³¨æ„ï¼šæˆ‘ä»¬ä¸æƒ³è¦†ç›–æœ¬åœ°çš„ resolution_typeï¼Œä½†éœ€è¦åŒæ­¥ GitHub çš„ is_resolved
                existing = thread_table.get(self.Thread.id == thread.id)
                
                if existing:
                    update_data = {
                        "is_resolved": thread.is_resolved,
                        "last_updated": datetime.utcnow().isoformat()
                    }
                    # å¦‚æœ GitHub ä¸Šå·²ç»æ˜¯ resolvedï¼Œå¼ºåˆ¶åŒæ­¥æœ¬åœ°çŠ¶æ€
                    if thread.is_resolved and existing['local_resolution_status'] != 'resolved':
                        update_data['local_resolution_status'] = 'resolved'
                        update_data['resolution_type'] = 'github_ui'
                    
                    thread_table.update(update_data, self.Thread.id == thread.id)
                else:
                    thread_table.insert(thread.model_dump())

    def mark_resolved_locally(self, thread_id: str, resolution_type: str):
        """API è°ƒç”¨æˆåŠŸåï¼Œæ›´æ–°æœ¬åœ°çŠ¶æ€"""
        with FileLock(self.lock_path):
            self.db.table("threads").update({
                "local_resolution_status": "resolved",
                "is_resolved": True,
                "resolution_type": resolution_type,
                "last_updated": datetime.utcnow().isoformat()
            }, self.Thread.id == thread_id)
            
    def get_pending_threads(self) -> List[ReviewThreadState]:
        """è·å–æ‰€æœ‰å¾…å¤„ç†çš„çº¿ç¨‹"""
        threads = self.db.table("threads").search(
            (self.Thread.local_resolution_status == "pending") & 
            (self.Thread.is_resolved == False)
        )
        return [ReviewThreadState(**t) for t in threads]
        
    def get_metadata(self) -> Optional[ReviewMetadata]:
        meta = self.db.table("metadata").all()
        return ReviewMetadata(**meta[0]) if meta else None
```

#### 5. GitHub è§‚å¯Ÿè€… (`src/review/github_observer.py`)

æ— éœ€å˜æ›´ï¼Œä¿æŒä¹‹å‰çš„ ETag è®¾è®¡å³å¯ã€‚

---

### ä¸‹ä¸€æ­¥æŒ‡ä»¤

æ‰€æœ‰åŸºç¡€è®¾æ–½ä»£ç å·²å°±ç»ªã€‚ä½ å¯ä»¥ç›´æ¥å°†ä¸Šè¿°ä»£ç å—ä¿å­˜åˆ°å¯¹åº”çš„æ–‡ä»¶ä¸­ã€‚

**æ¥ä¸‹æ¥çš„æ“ä½œå»ºè®®ï¼š**

1. **è¿è¡Œ `pip install httpx tenacity pydantic tinydb filelock`** ç¡®ä¿ä¾èµ–å°±ç»ªã€‚
2. **åˆ›å»º `tools/debug_fetch.py`**ï¼šç¼–å†™ä¸€ä¸ªç®€å•çš„è„šæœ¬è°ƒç”¨ `GraphQLClient` çš„ `fetch_pr_threads` æ–¹æ³•ï¼Œæ‰“å°å‡ºçœŸå®çš„ Node IDï¼ŒéªŒè¯ GitHub API çš„è¿é€šæ€§ã€‚è¿™æ˜¯åœ¨é›†æˆåˆ° Agent ä¹‹å‰æœ€é‡è¦çš„ "å†’çƒŸæµ‹è¯•"ã€‚
